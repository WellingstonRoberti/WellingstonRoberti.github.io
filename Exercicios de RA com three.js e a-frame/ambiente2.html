<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Exercício 1</title>
    <!-- include three.js library -->
    <script src='js/three.min.js'></script>
    <script src='js/OBJLoader.js'></script>
    <script src='js/MTLLoader.js'></script>
    <!-- include jsartookit -->
    <script src="jsartoolkit5/artoolkit.min.js"></script>
    <script src="jsartoolkit5/artoolkit.api.js"></script>
    <!-- include threex.artoolkit -->
    <script src="threex/threex-artoolkitsource.js"></script>
    <script src="threex/threex-artoolkitcontext.js"></script>
    <script src="threex/threex-arbasecontrols.js"></script>
    <script src="threex/threex-armarkercontrols.js"></script>
</head>
<body>
    <script>
        var scene, camera, renderer, clock, deltaTime, totalTime;

        var arToolkitSource, arToolkitContext;

        var markerHiro, markerKanji, markerA, markerB, markerC, markerD, markerG, markerF;
        var markerControlsHiro, markerControlsKanji, markerControlsA, markerControlsB, markerControlsC, markerControlsD, markerControlsG, markerControlsF;

        var meshModel, meshLight;
        let sceneGroupA = new THREE.Group();
        let sceneGroupB = new THREE.Group();
        let sceneGroupC = new THREE.Group();
        let sceneGroupD = new THREE.Group();
        let sceneGroupF = new THREE.Group();
        let sceneGroupG = new THREE.Group();
        let sceneGroupHiroA = new THREE.Group();
        let sceneGroupHiroB = new THREE.Group();
        let sceneGroupHiroC = new THREE.Group();
        let sceneGroupHiroD = new THREE.Group();
        let sceneGroupHiroF = new THREE.Group();
        let sceneGroupHiroG = new THREE.Group();

        initialize();
        animate();
        
        function initialize() {
            scene = new THREE.Scene();

            camera = new THREE.Camera();
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({
                antialias : true,
                alpha: true
            });
            renderer.setClearColor(new THREE.Color('lightgrey'), 0)
            renderer.setSize( window.innerWidth*1, window.innerHeight*1 );
            renderer.domElement.style.position = 'absolute'
            renderer.domElement.style.top = '0px'
            renderer.domElement.style.left = '0px'
            document.body.appendChild( renderer.domElement );

            clock = new THREE.Clock();
            deltaTime = 0;
            totalTime = 0;

            ////////////////////////////////////////////////////////////
            // setup arToolkitSource
            ////////////////////////////////////////////////////////////

            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType : 'webcam',
            });

            function onResize()
            {
                arToolkitSource.onResize()
                arToolkitSource.copySizeTo(renderer.domElement)
                if ( arToolkitContext.arController !== null )
                {
                    arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
                }
            }

            arToolkitSource.init(function onReady(){
                onResize()
            });

            // handle resize event
            window.addEventListener('resize', function(){
                onResize()
            });

            ////////////////////////////////////////////////////////////
            // setup arToolkitContext
            ////////////////////////////////////////////////////////////

            // create atToolkitContext
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'data/camera_para.dat',
                detectionMode: 'mono'
            });

            // copy projection matrix to camera when initialization complete
            arToolkitContext.init( function onCompleted(){
                camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
            });

            ////////////////////////////////////////////////////////////
            // setup markerRoots
            ////////////////////////////////////////////////////////////

            // build markerControls
            markerHiro = new THREE.Group();
            scene.add(markerHiro);
            markerControlsHiro = new THREEx.ArMarkerControls(arToolkitContext, markerHiro, {
                type: 'pattern', patternUrl: "data/hiro.patt",
            })

            markerKanji = new THREE.Group();
            scene.add(markerKanji);
            markerControlsKanji = new THREEx.ArMarkerControls(arToolkitContext, markerKanji, {
                type: 'pattern', patternUrl: "data/kanji.patt",
            })

            markerA = new THREE.Group();
            scene.add(markerA);
            markerControlsA = new THREEx.ArMarkerControls(arToolkitContext, markerA, {
                type: 'pattern', patternUrl: "data/letterA.patt",
            })

            markerB = new THREE.Group();
            scene.add(markerB);
            markerControlsB = new THREEx.ArMarkerControls(arToolkitContext, markerB, {
                type: 'pattern', patternUrl: "data/letterB.patt",
            })

            markerC = new THREE.Group();
            scene.add(markerC);
            markerControlsC = new THREEx.ArMarkerControls(arToolkitContext, markerC, {
                type: 'pattern', patternUrl: "data/letterC.patt",
            })

            markerD = new THREE.Group();
            scene.add(markerD);
            markerControlsD = new THREEx.ArMarkerControls(arToolkitContext, markerD, {
                type: 'pattern', patternUrl: "data/letterD.patt",
            })

            markerF = new THREE.Group();
            scene.add(markerF);
            markerControlsF = new THREEx.ArMarkerControls(arToolkitContext, markerF, {
                type: 'pattern', patternUrl: "data/letterF.patt",
            })

            markerG = new THREE.Group();
            scene.add(markerG);
            markerControlsG = new THREEx.ArMarkerControls(arToolkitContext, markerG, {
                type: 'pattern', patternUrl: "data/letterG.patt",
            })


            ////////////////////////////////////////////////////////////
            // setup scene
            ////////////////////////////////////////////////////////////

            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            let sceneGroupHiro = new THREE.Group();
            let sceneGroupKanji = new THREE.Group();
            markerHiro.add(sceneGroupHiro);
            markerKanji.add(sceneGroupKanji);

            //chão para sombra para cada objeto
            let floorGeometry = new THREE.PlaneGeometry( 10,10 );
            let floorMaterial = new THREE.ShadowMaterial();
            floorMaterial.opacity = 0.3;
            let floorMeshA = new THREE.Mesh( floorGeometry, floorMaterial );
            floorMeshA.rotation.x = -Math.PI/2;
            floorMeshA.receiveShadow = true;

            let floorMeshB = new THREE.Mesh( floorGeometry, floorMaterial );
            floorMeshB.rotation.x = -Math.PI/2;
            floorMeshB.receiveShadow = true;

            let floorMeshC = new THREE.Mesh( floorGeometry, floorMaterial );
            floorMeshC.rotation.x = -Math.PI/2;
            floorMeshC.receiveShadow = true;

            let floorMeshD = new THREE.Mesh( floorGeometry, floorMaterial );
            floorMeshD.rotation.x = -Math.PI/2;
            floorMeshD.receiveShadow = true;

            let floorMeshF = new THREE.Mesh( floorGeometry, floorMaterial );
            floorMeshF.rotation.x = -Math.PI/2;
            floorMeshF.receiveShadow = true;

            let floorMeshG = new THREE.Mesh( floorGeometry, floorMaterial );
            floorMeshG.rotation.x = -Math.PI/2;
            floorMeshG.receiveShadow = true;

            
            let light = new THREE.PointLight(0xffffff);
            light.position.set(0, 2, 0);
            light.castShadow = true;
            sceneGroupKanji.add( light );
            sceneGroupHiro.add( light );
            var geometry = new THREE.SphereGeometry( .1 );
            var material = new THREE.MeshBasicMaterial( { color: "white", transparent: true } );
            Sphere = new THREE.Mesh( geometry, material );
            Sphere.position.copy( light.position );
            sceneGroupKanji.add( Sphere );
            sceneGroupHiro.add( Sphere );

            //Objetos para cada marcador
            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshLambertMaterial( { color: "blue" } );
            cube1 = new THREE.Mesh( geometry, material );
            //cube.rotation.set(10,30,0);
            cube1.castShadow = true;
            sceneGroupA.add( cube1 );
            sceneGroupA.add( floorMeshA );

            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshLambertMaterial( { color: "red" } );
            cube2 = new THREE.Mesh( geometry, material );
            //cube.rotation.set(10,30,0);
            cube2.castShadow = true;
            sceneGroupB.add( cube2 );
            sceneGroupB.add( floorMeshB );

            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshLambertMaterial( { color: "yellow" } );
            cube3 = new THREE.Mesh( geometry, material );
            //cube.rotation.set(10,30,0);
            cube3.castShadow = true;
            sceneGroupC.add( cube3 );
            sceneGroupC.add( floorMeshC );

            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshLambertMaterial( { color: "orange" } );
            cube4 = new THREE.Mesh( geometry, material );
            //cube.rotation.set(10,30,0);
            cube4.castShadow = true;
            sceneGroupD.add( cube4 );
            sceneGroupD.add( floorMeshD );
            
            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshLambertMaterial( { color: "darkgreen" } );
            cube5 = new THREE.Mesh( geometry, material );
            //cube.rotation.set(10,30,0);
            cube5.castShadow = true;
            sceneGroupF.add( cube5 );
            sceneGroupF.add( floorMeshF );

            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshLambertMaterial( { color: "purple" } );
            cube6 = new THREE.Mesh( geometry, material );
            //cube.rotation.set(10,30,0);
            cube6.castShadow = true;
            sceneGroupG.add( cube6 );
            sceneGroupG.add( floorMeshG );        

            markerA.add(sceneGroupA);
            markerB.add(sceneGroupB);
            markerC.add(sceneGroupC);
            markerD.add(sceneGroupD);
            markerF.add(sceneGroupF);
            markerG.add(sceneGroupG);
            

            //cenas com o hiro junto
            var geometry = new THREE.SphereGeometry( 1 );
            var material = new THREE.MeshLambertMaterial( { color: "blue" } );
            Sphere1 = new THREE.Mesh( geometry, material );
            //Sphere.rotation.set(10,30,0);
            Sphere1.castShadow = true;
            sceneGroupHiroA.add( Sphere1 );
            sceneGroupHiroA.add( floorMeshA );

            var geometry = new THREE.SphereGeometry( 1 );
            var material = new THREE.MeshLambertMaterial( { color: "red" } );
            Sphere2 = new THREE.Mesh( geometry, material );
            //Sphere.rotation.set(10,30,0);
            Sphere2.castShadow = true;
            sceneGroupHiroB.add( Sphere2 );
            sceneGroupHiroB.add( floorMeshB );

            var geometry = new THREE.SphereGeometry( 1 );
            var material = new THREE.MeshLambertMaterial( { color: "yellow" } );
            Sphere3 = new THREE.Mesh( geometry, material );
            //Sphere.rotation.set(10,30,0);
            Sphere3.castShadow = true;
            sceneGroupHiroC.add( Sphere3 );
            sceneGroupHiroC.add( floorMeshC );

            var geometry = new THREE.SphereGeometry( 1 );
            var material = new THREE.MeshLambertMaterial( { color: "orange" } );
            Sphere4 = new THREE.Mesh( geometry, material );
            //Sphere.rotation.set(10,30,0);
            Sphere4.castShadow = true;
            sceneGroupHiroD.add( Sphere4 );
            sceneGroupHiroD.add( floorMeshD );
            
            var geometry = new THREE.SphereGeometry( 1 );
            var material = new THREE.MeshLambertMaterial( { color: "darkgreen" } );
            Sphere5 = new THREE.Mesh( geometry, material );
            //Sphere.rotation.set(10,30,0);
            Sphere5.castShadow = true;
            sceneGroupHiroF.add( Sphere5 );
            sceneGroupHiroF.add( floorMeshF );

            var geometry = new THREE.SphereGeometry( 1 );
            var material = new THREE.MeshLambertMaterial( { color: "purple" } );
            Sphere6 = new THREE.Mesh( geometry, material );
            //Sphere.rotation.set(10,30,0);
            Sphere6.castShadow = true;
            sceneGroupHiroG.add( Sphere6 );
            sceneGroupHiroG.add( floorMeshG );
        }
        function animate()
        {
            requestAnimationFrame(animate);
            deltaTime = clock.getDelta();
            totalTime += deltaTime;
            update();
            render();
        }

        function update()
        {
            if(markerControlsHiro.object3d.visible){
                markerA.remove(sceneGroupA);
                markerB.remove(sceneGroupB);
                markerC.remove(sceneGroupC);
                markerD.remove(sceneGroupD);
                markerF.remove(sceneGroupF);
                markerG.remove(sceneGroupG);
                //console.log("teste");
                markerA.add(sceneGroupHiroA);
                markerB.add(sceneGroupHiroB);
                markerC.add(sceneGroupHiroC);
                markerD.add(sceneGroupHiroD);
                markerF.add(sceneGroupHiroF);
                markerG.add(sceneGroupHiroG);
            }else{
                //console.log("teste1");
                markerA.remove(sceneGroupHiroA);
                markerB.remove(sceneGroupHiroB);
                markerC.remove(sceneGroupHiroC);
                markerD.remove(sceneGroupHiroD);
                markerF.remove(sceneGroupHiroF);
                markerG.remove(sceneGroupHiroG);
                markerA.add(sceneGroupA);
                markerB.add(sceneGroupB);
                markerC.add(sceneGroupC);
                markerD.add(sceneGroupD);
                markerF.add(sceneGroupF);
                markerG.add(sceneGroupG);
            }
            // update artoolkit on every frame
            if ( arToolkitSource.ready !== false )
                arToolkitContext.update( arToolkitSource.domElement );
        }

        function render()
        {
            renderer.render( scene, camera );
        }
    </script>
</body>
</html>